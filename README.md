# Среда разработки

BRAS - сокращенно от Backend RESTful API Server, backend сервер API запросов в формате REST.

Это сервер, построенный на базе Node.js, который может использоваться в качестве backend части для ваших веб приложений.

# Оглавление

- [Быстрый старт](#быстрый-старт)
- [О проекте](#о-проекте)
  - [Состав](#состав)
  - [Структура](#структура)
- [API](#api)
- [Базы данных](#базы-данных)
  - [GraphQL](#graphql)
  - [Prisma](#prisma)
  - [Прямая обработка запросов](#прямая-обработка-запросов)
- [Расширение функционала](#расширение-функционала)
  - [Установка зависимостей](#установка-зависимостей)
  - [Подключение библиотек](#подключение-библиотек)

# Быстрый старт

Быстрый запуск в 5 простых шагов.

**1**. Выполните клонирование данного репозитория в текущий каталог backend части вашего проекта.

```shell script
git clone https://github.com/isengine/bras .
```

**2**. Выполните компиляцию

Рекомендуем использовать **yarn**.

```shell script
yarn
```

**3**. Сделайте настройки

Разверните базу данных.

Внесите необходимые настройки в файл **.env**.

Запрограммируйте нужные пути и методы.

**4**. Соберите проект

В режиме **production**:

```shell script
yarn start
```

В режиме разработки **development**:

```shell script
yarn dev
```

Вывод проекта через node.js на 8080 порт: http://localhost:8080

Вывод статики из каталога "./public/" через сервер nginx + php-fpm на 80 порт: http://localhost

> В случае необходимости изменить конфигурацию сервера, возникновения ошибок и прочих вопросов, смотрите полное руководство.

[^ к оглавлению](#оглавление)

# О проекте

## Состав

Backend использует следующие технологии:

- apollo
- axios
- express
- graphql
- jwt
- mysql
- nodejs
- postgres
- prisma
- yarn

[^ к оглавлению](#оглавление)

## Структура

```
bras
├── apollo
│   ├── schema
│   │   ├── mutations
│   │   ├── queries
│   │   ├── resolvers
│   │   ├── resolvers.js
│   │   └── typeDefs.js
│   ├── apollo.js
│   └── schema.js
├── app
│   ├── METHOD
│   │   ├── controllers
│   │   ├── middlewares
│   │   ├── models
│   │   ├── services
│   │   ├── METHOD.controllers.js
│   │   ├── METHOD.middlewares.js
│   │   ├── METHOD.models.js
│   │   └── METHOD.services.js
│   └── routes.js
├── prisma
│   ├── prisma.js
│   └── schema.prisma
├── .env
├── package.json
└── server.js
```

[^ к оглавлению](#оглавление)

# API

Работа с API предлагает использовать всю мощь фреймворка Express.js и платформы Node.js.

Мы используем стандарт RESTful API.

Так выглядит пример запроса:

```
/api/resource/endpoint
```

- **api** является точкой входа,
- **resource** указывает на запрашиваемый ресурс,
- **endpoint** может содержать сложный путь, даже с некоторыми параметрами.

Параметры запроса передаются в виде JSON.

Вызываемый ресурс контролируется в файле **routes.js**. Там же назначается метод HTTP-запроса:

- GET, получает полные данные (тело и заголовки),
- HEAD, получает только заголовки (служебную информацию),
- POST, отправляет данные на сервер,
- PUT, отправляет запрос на создание нового ресурса на сервере, либо на замену существующего,
- PATCH, отправляет запрос на изменение фрагмента ресурса,
- DELETE, отправляет запрос на удаление ресурса,
- CONNECT, устанавливает постоянную двунаправленную связь (туннель) с сервером,
- OPTIONS, отправляет запрос на получение параметров соединения,
- TRACE, отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе).

Методы GET, HEAD и OPTIONS считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию методы GET и HEAD кэшируются, остальные - нет. Поэтому при использовании метода POST можно быть уверенным, что запрос выполнится. В случае с GET Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

Также **routes.js** назначает один или несколько обработчиков для этого ресурса.

Ресурсы представляют собой четко структурированные папки. Мы призываем придерживаться этой структуры в создании собственных ресурсов.

Обработчики представляют из себя контроллеры или middleware и лежат в соответствующих папках.

В большинстве случаев контроллеры отправляют запросы в базу данных и, возможно, дополнительно обрабатывают данные. Но также контроллеры могут содержать и другие действия, например, по работе с файлами.

Все эти действия лежат в папке **services**.

Еще одна папка содержит модели данных. Эти модели могут понадобится при обработке данных. Например, после запроса в базу, мы можем получить больше данных, чем захотим отдать. Модель указывает на те данные, которые мы хотим вернуть.

Типовой пример - пароль пользователя. Он приходит в запросе и мы должны его сверить. Кончно, он хешированный, но даже в таком виде нам незачем его передавать в приложение.

Другой пример - номер телефона или email, который может служить для авторизации, но мы также не будет его передавать в приложение.

Такая структура позволяет создать максимально понятное API, удобное для программирования, со слабо связанными компонентами.

Также при написании контроллеров и middleware, вы можете использовать свои сервисы, подключенные в виде библиотек.

[^ к оглавлению](#оглавление)

# Базы данных

Для работы с базами данных мы предлагаем несколько способов:

- GraphQL через Apollo + Prisma
- ORM Prisma
- прямая обработка запросов

Конечно, в приоритете GraphQL. Если вам это кажется еще сложным, либо вы на пути миграции вашего приложения, рекомендуемый выбор - Prisma.

Почему мы не рекомендуем осуществлять прямую обработку запросов? Смотрите, вам придется самостоятельно:

- устанавливать и настраивать расширения для Express.js,
- писать запросы,
- контролировать безопасность принимаемых данных,
- осуществлять типизацию выходных данных.

[^ к оглавлению](#оглавление)

## GraphQL

Работа с GraphQL построена на связке Apollo + Prisma.

Apollo является лучшим решением, а Prisma позволяет контролировать типизацию.

Данная связка на данный момент является самой перспективной. Во-первых, она очень быстро развивается. Во-вторых, она может сделать переход вашего приложения на GraphQL минимально безболезненным.

Команда Prisma является активными участниками сообщества разработчиков GraphQL. Уже сейчас мы можем получить более удобные способы взаимодействия Prisma с GraphQL, например, минуя Apollo.

В свою очередь Apollo также активно развивается. Уже сейчас решения предлагают работу с не только с базами данных, но и с API, и со статическим контентом. В дальнейшем мы можем отказаться от фреймворка Express.js в пользу Apollo.

И это является еще одной причиной не использовать прямую обработку запросов.

[^ к оглавлению](#оглавление)

## Prisma

Prisma дает возможность работать с любой из следующих баз данных:

- MongoDB,
- MySQL,
- PostgreSQL,
- SQLite

и некоторыми другими.

Причем настройка и подключение осуществляются парой строк кода со сменой провайдера.

Вся работа построена на прописывании схемы с моделями данных в собственном формате Prisma. С одной стороны это лишний костыль, с другой это позволяет использовать большую мощь Prisma.

Например, вы получаете:

- типизированную структуру,
- простую миграцию.

Существуют библиотеки, позволяющие из схемы Prisma построить схему GraphQL.

Обновление базы данных может происходить за счет вызова миграции.

```shell script
prisma migrate dev
```

[^ к оглавлению](#оглавление)

## Прямая обработка запросов

Подробнее см. здесь:

https://expressjs.com/ru/guide/database-integration.html

[^ к оглавлению](#оглавление)

# Расширение функционала

## Установка зависимостей

Вы можете расширять возможности сервера при помощи библиотек. Такие библиотеки в контексте установки в проект называются зависимостями.

Установить библиотеку:

```shell script
yarn add LIBRARY
```

Удалить библиотеку:

```shell script
yarn remove LIBRARY
```

Также можно устанавливать и удалять несколько библиотек сразу, перечислив их через пробел:

```shell script
yarn add LIBRARY1 LIBRARY2 LIBRARY3
```

[^ к оглавлению](#оглавление)

## Подключение библиотек

Подключать библиотеки к проекту нужно в каждом **js** файле, где вы будете их использовать.

Подключить библиотеку к проекту:

```
import LIBRARY from 'LIBRARY'
```

Подключить определенные константы, объекты или функции:

```
import { OBJECT1, OBJECT2 } from 'LIBRARY'
```

Подключить все ресурсы библиотеки:

```
import * from 'LIBRARY'
```

[^ к оглавлению](#оглавление)
