# Среда разработки

BRAS - сокращенно от Backend RESTful API Server, backend сервер API запросов в формате REST.

Это сервер, построенный на базе Node.js, который может использоваться в качестве backend части для ваших веб приложений.

# Оглавление

- [Быстрый старт](#быстрый-старт)
- [О проекте](#о-проекте)
  - [Состав](#состав)
  - [Структура](#структура)
- [API](#api)
  - [Запросы к API](#запросы-к-api)
  - [Путь к API](#путь-к-api)
- [Базы данных](#базы-данных)
  - [GraphQL](#graphql)
  - [Prisma](#prisma)
    - [Возможности Prisma](#возможности-prisma)
    - [Подключение Prisma](#подключение-prisma)
    - [Схема Prisma](#схема-prisma)
    - [Зависимости в Prisma](#зависимости-в-prisma)
    - [Миграции в Prisma](#миграции-в-prisma)
    - [Prisma Studio](#prisma-studio)
    - [Запросы в Prisma](#запросы-в-prisma)
    - [Вложенные запросы в Prisma](#вложенные-запросы-в-prisma)
    - [Поля запросов в Prisma](#поля-запросов-в-prisma)
    - [Фильтры и операторы в Prisma](#фильтры-и-операторы-в-prisma)
  - [Прямая обработка запросов](#прямая-обработка-запросов)
- [Встроенные возможности](#встроенные-возможности)
  - [Авторизация](#авторизация)
    - [Авторизация по номеру телефона](#авторизация-по-номеру-телефона)
    - [Авторизация без подтверждения](#авторизация-без-подтверждения)
    - [Двухфакторная аутентификация](#двухфакторная-аутентификация)
- [Расширение функционала](#расширение-функционала)
  - [Установка зависимостей](#установка-зависимостей)
  - [Подключение библиотек](#подключение-библиотек)
  - [Сервер статики](#сервер-статики)
  - [Рабочее окружение](#рабочее-окружение)
- [Правила](#правила)
  - [Именование](#именование)
    - [Обычное именование](#обычное-именование)
    - [Именование в базах данных](#именование-в-базах-данных)
    - [Именование сущностей булевого типа](#именование-сущностей-булевого-типа)
    - [Именование действий](#именование-действий)
    - [Именование определений](#именование-определений)
    - [Полное и краткое именование](#полное-и-краткое-именование)
    - [Именование файлов](#именование-файлов)
    - [Что дают правила именования](#что-дают-правила-именования)

# Быстрый старт

Быстрый запуск в 5 простых шагов.

**1**. Выполните клонирование данного репозитория в текущий каталог backend части вашего проекта.

```shell script
git clone https://github.com/isengine/bras .
```

**2**. Выполните компиляцию

Рекомендуем использовать **yarn**.

```shell script
yarn
```

**3**. Сделайте настройки

Внесите необходимые настройки в файле **.env**.

- режим компиляции,
- порт,
- ключ для jwt токена,
- путь к API,
- путь к интерфейсу GraphQL.

Добавьте нужные пути и методы в файле **routes.js**.

**4**. Разверните базу данных

Укажите путь к базе данных в файле **.env**.

При необходимости, выполните компиляцию

```
./prisma/generate
```

И миграцию

```
yarn prisma migrate dev
```

**5**. Соберите проект

В режиме **production**:

```shell script
yarn start
```

В режиме разработки **development**:

```shell script
yarn dev
```

Вывод проекта через node.js на 8080 порт: http://localhost:8080

> В случае необходимости изменить конфигурацию сервера, возникновения ошибок и прочих вопросов, смотрите полное руководство.

[^ к оглавлению](#оглавление)

# О проекте

## Состав

Backend использует следующие технологии:

- express
- graphql
- jwt
- mysql
- nodejs
- postgres
- prisma
- yarn

[^ к оглавлению](#оглавление)

## Структура

```
bras
├── api
│   ├── RESOURCE
│   │   ├── controller
│   │   ├── dto
│   │   ├── middleware
│   │   ├── model
│   │   ├── service
│   │   ├── RESOURCE.controller.js
│   │   ├── RESOURCE.dto.js
│   │   ├── RESOURCE.middleware.js
│   │   ├── RESOURCE.model.js
│   │   └── RESOURCE.service.js
│   └── routes.js
├── prisma
│   ├── prisma.js
│   └── schema.prisma
├── schema
│   ├── mutations
│   ├── queries
│   ├── resolvers
│   ├── resolvers.js
│   ├── schema.js
│   └── typeDefs.js
├── .env
├── package.json
└── server.js
```

[^ к оглавлению](#оглавление)

# API

## Запросы к API

Работа с API предлагает использовать всю мощь фреймворка Express.js и платформы Node.js.

Мы используем стандарт RESTful API.

Так выглядит пример запроса:

```
/api/resource/endpoint
```

- **api** является точкой входа,
- **resource** указывает на запрашиваемый ресурс,
- **endpoint** может содержать сложный путь, даже с некоторыми параметрами.

Параметры запроса передаются в виде JSON.

Вызываемый ресурс контролируется в файле **routes.js**. Там же назначается метод HTTP-запроса:

- GET, получает полные данные (тело и заголовки),
- HEAD, получает только заголовки (служебную информацию),
- POST, отправляет данные на сервер,
- PUT, отправляет запрос на создание нового ресурса на сервере, либо на замену существующего,
- PATCH, отправляет запрос на изменение фрагмента ресурса,
- DELETE, отправляет запрос на удаление ресурса,
- CONNECT, устанавливает постоянную двунаправленную связь (туннель) с сервером,
- OPTIONS, отправляет запрос на получение параметров соединения,
- TRACE, отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе).

Методы GET, HEAD и OPTIONS считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию методы GET и HEAD кэшируются, остальные - нет. Поэтому при использовании метода POST можно быть уверенным, что запрос выполнится. В случае с GET Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

Также **routes.js** назначает один или несколько обработчиков для этого ресурса.

Ресурсы представляют собой четко структурированные папки. Мы призываем придерживаться этой структуры в создании собственных ресурсов.

Обработчики представляют из себя контроллеры или middleware и лежат в соответствующих папках.

В большинстве случаев контроллеры отправляют запросы в базу данных и, возможно, дополнительно обрабатывают данные. Но также контроллеры могут содержать и другие действия, например, по работе с файлами.

Все эти действия лежат в папке **services**.

Еще одна папка содержит модели данных. Эти модели могут понадобится при обработке данных. Например, после запроса в базу, мы можем получить больше данных, чем захотим отдать. Модель указывает на те данные, которые мы хотим вернуть.

Типовой пример - пароль пользователя. Он приходит в запросе и мы должны его сверить. Кончно, он хешированный, но даже в таком виде нам незачем его передавать в приложение.

Другой пример - номер телефона или email, который может служить для авторизации, но мы также не будет его передавать в приложение.

Такая структура позволяет создать максимально понятное API, удобное для программирования, со слабо связанными компонентами.

Также при написании контроллеров и middleware, вы можете использовать свои сервисы, подключенные в виде библиотек.

[^ к оглавлению](#оглавление)

## Путь к API

Путь настраивается в файле **.env** в переменной окружения **API_BASE**.

По-умолчанию:

```
API_BASE = /api
```

Если вы используете для вашего API отдельный домен, вы можете указать пустой путь:

```
API_BASE =
```

Если вы используете разные версии API, то вы можете добавить к пути номер версии. Например, так:

```
API_BASE = /api/v3
```

[^ к оглавлению](#оглавление)

# Базы данных

Для работы с базами данных мы предлагаем несколько способов:

- GraphQL
- ORM Prisma
- прямая обработка запросов

Конечно, в приоритете GraphQL. Если вам это кажется еще сложным, либо вы на пути миграции вашего приложения, рекомендуемый выбор - Prisma.

Почему мы не рекомендуем осуществлять прямую обработку запросов? Смотрите, вам придется самостоятельно:

- устанавливать и настраивать расширения для Express.js,
- писать запросы,
- контролировать безопасность принимаемых данных,
- осуществлять типизацию выходных данных.

[^ к оглавлению](#оглавление)

## GraphQL

Работа с GraphQL построена на связке расширения для Express.js + GraphiQL + Prisma.

Данная связка на данный момент является самой перспективной. Во-первых, она очень быстро развивается. Во-вторых, она может сделать переход вашего приложения на GraphQL минимально безболезненным.

И это является еще одной причиной не использовать прямую обработку запросов.

Команда Prisma является активными участниками сообщества разработчиков GraphQL. Уже сейчас мы можем получить более удобные способы взаимодействия Prisma с GraphQL.

Раньше мы использовали Apollo, но это нам показалось не лучшим решением, т.к. приходилось вызывать Apollo как middleware в Express. Мы не использовали Apollo никак, кроме обеспечения работы с GraphQL, и поэтому отказались от него в пользу решения непосредственно для Express.js.

Однако Apollo является более перспективным, чем Express. Он активно развивается. И в дальнейшем мы можем отказаться от фреймворка Express.js в пользу Apollo.

Схема GraphQL находится в папке **schema**. Для удобства она разбита на **resolvers**, **queries** и **mutations**. Все сущности из этих папок собираются в файле **resolvers.js**. Определение типов по-прежнему задается в одном файле **typeDefs.js**.

Схема доступна из кода:

```
import { schema } from '#schema/schema'
```

Мы работаем над тем, чтобы типы тоже можно было задавать в разных файлах.

[^ к оглавлению](#оглавление)

## Prisma

### Возможности Prisma

Prisma позволяет контролировать типизацию и упрощает работу.

Prisma дает возможность работать с любой из следующих баз данных:

- MongoDB,
- MySQL,
- PostgreSQL,
- SQLite

и некоторыми другими.

Причем настройка и подключение осуществляются парой строк кода со сменой провайдера.

Вся работа построена на прописывании схемы с моделями данных в собственном формате Prisma. С одной стороны это лишний костыль, с другой это позволяет использовать большую мощь Prisma.

Например, вы получаете:

- типизированную структуру,
- простую миграцию.

[^ к оглавлению](#оглавление)

### Подключение Prisma

Схема Prisma находится в папке **prisma** и по-прежнему задается в одном файле **schema.prisma**.

Вы можете также разделить схему на разные файлы.

Файлы схемы нужно расположить в папке **prisma/schema**.

Файлы должны быть с расширением **.prisma**.

Имена должны следовать в том порядке, в котором они будут идти в таблице.

Можно нумеровать их:

```
00_base.prisma
01_auth.prisma
...
```

Для объединения файлов, нужно выполнить компиляцию в командной строке из корневой папки проекта

```
./prisma/generate
```

> После объединения рекомендуем выполнить миграцию

Схема доступна из кода:

```
import { prisma } from '#prisma'
```

[^ к оглавлению](#оглавление)

### Схема Prisma

Типы данных:

- **String** — строка,
- **Boolean** — логическое значение: true или false,
- **Int** — целое число,
- **BigInt** — BigInt,
- **Float** — число с плавающей точкой,
- **Decimal** — decimal(65,30),
- **DateTime** — дата и время в формате ISO 8601,
- **Json** — объект в формате JSON,
- **Bytes** — bytea.

Модификаторы:

- **?** указывает на то, что поле является необязательным и может иметь значение **NULL**,
- **[]** указывает на то, что значением данного поля является массив.

Префиксы:

- **@** обозначает атрибут поля,
- **@@** обозначает атрибут блока.

Атрибуты:

- @id означает, что данное поле является первичным ключом таблицы (PRIMARY KEY),
- @default(...) присваивает полю значение по умолчанию (при отсутствии значения поля),
- @map("name") привязывает поле схемы к указанной колонке **name** таблицы,
- @@map("name") привязывает название модели к названию таблицы **name** в БД,
- @relation задает отношения между таблицами,
- @unique означает, что значение поля должно быть уникальным в пределах таблицы,
- @updatedAt обновляет поле текущими датой и временем при любой модификации записи.

Функции атрибутов:

- auto — представляет дефолтные значения, генерируемые БД (только для MongoDB),
- autoincrement — генерирует последовательные целые числа (кроме MongoDB),
- cuid — генерирует глобальный уникальный идентификатор на основе спецификации cuid,
- uuid — генерирует глобальный уникальный идентификатор на основе спецификации UUID,
- now — возвращает текущую отметку времени.

[^ к оглавлению](#оглавление)

### Зависимости в Prisma

Чтобы настроить в Prisma зависимости между двумя таблицами, нужно связать обе таблицы.

Для этого нужно задать поле, у которого значением будет название таблицы, с которой будет зависимость.

Затем прописать связи в атрибуте **@relation**:

- **fields** — список полей текущей модели,
- **references** — список полей другой модели.

Обратите внимание, **fields** и **references** — массивы и могут содержать несколько связей.

```
model Auth {
  id     Int    @id @default(autoincrement())
  ...
  user   User?
}

model User {
  id     Int   @id @default(autoincrement())
  ...
  userId Int?  @map("user_id")
  auth   Auth? @relation(fields: [userId], references: [id])
  ...
  # один ко многим
  posts  Post[]
}
```

Отношения один к одному:

```
model First {
  id      Int      @id @default(autoincrement())
  ...
  second  Second?
}

model Second {
  id      Int      @id @default(autoincrement())
  ...
  firstId Int?     @map("first_id")
  first   First?   @relation(fields: [firstId], references: [id])
}
```

Отношения один ко многим:

```
model First {
  id      Int      @id @default(autoincrement())
  ...
  seconds Second[]
}

model Second {
  id      Int      @id @default(autoincrement())
  ...
  firstId Int?     @map("first_id")
  first   First?   @relation(fields: [firstId], references: [id])
}
```

Отношения многие ко многим:

```
model First {
  id      Int      @id @default(autoincrement())
  ...
  seconds Second[]
}

model Second {
  id      Int      @id @default(autoincrement())
  ...
  firsts  First[]
}
```

[^ к оглавлению](#оглавление)

### Миграции в Prisma

Обновление базы данных происходит за счет вызова миграции.

```shell script
prisma migrate dev
```

При вызове этой команды будут выполнены следующие действия:

- создание БД при ее отсутствии,
- генерация файла prisma/migrations/migration_name.sql,
- синхронизация БД со схемой,
- генерация клиента (аналогично **prisma generate**).

Производственная миграция:

```shell script
prisma migrate deploy
```

Удалить и заново создать БД, удаляя все данные, таблицы, индексы и другие артефакты:

```shell script
prisma migrate reset
```

Сгенерировать модели на основе существующей схемы БД:

```shell script
prisma db pull
```

Синхронизировать состояние схемы Prisma с БД без выполнения миграций:

```shell script
prisma db push
```

БД создается при отсутствии. Используется для прототипировании БД и в локальной разработке. Также может быть полезной в случае ограниченного доступа к БД, например, при использовании БД, предоставляемой облачными провайдерами.

[^ к оглавлению](#оглавление)

### Prisma Studio

Это интерфейс, который позволяет просматривать и управлять данными, хранящимися в БД, в интерактивном режиме.

```shell script
prisma studio
```

Вы можете назначить нужный порт (по умолчанию **5555**):

```shell script
prisma studio --port ХХХХ
# или
prisma studio -p ХХХХ
```

[^ к оглавлению](#оглавление)

### Запросы в Prisma

Модификатор **?** означает, что атрибут можен быть пропущен.

Обычно все атрибуты, кроме **where** могут быть пропущены.

Обычно при отсутствии записи возвращается **null**.

#### findUnique

Позволяет извлекать единичные записи по идентификатору или уникальному полю.

```
findUnique({
  where: condition,
  select?: fields,
  include?: relations,
  rejectOnNotFound?: boolean
})
```

- condition — условие для выборки;
- fields — поля для выборки;
- relations — отношения (связанные поля) для выборки;
- rejectOnNotFound — если имеет значение true, при отсутствии записи выбрасывается исключение NotFoundError. Если имеет значение false, при отсутствии записи возвращается null.

[^ к оглавлению](#оглавление)

#### findFirst

Возвращает первую запись, соответствующую заданному критерию.

```
findFirst({
  where?: condition,
  select?: fields,
  include?: relations,
  rejectOnNotFound?: boolean,
  distinct?: field,
  orderBy?: order,
  cursor?: position,
  skip?: number,
  take?: number
})
```

- distinct — фильтрация по определенному полю;
- orderBy — сортировка по определенному полю и в определенном порядке;
- cursor — позиция начала списка (как правило, id или другое уникальное значение);
- skip — количество пропускаемых записей;
- take — количество возвращаемых записей (в данном случае может иметь значение 1 или -1: во втором случае возвращается последняя запись.

[^ к оглавлению](#оглавление)

#### findMany

Возвращает все записи, соответствующие заданному критерию.

```
findMany({
  where?: condition,
  select?: fields,
  include?: relations,
  rejectOnNotFound?: boolean,
  distinct?: field,
  orderBy?: order,
  cursor?: position,
  skip?: number,
  take?: number
})
```

[^ к оглавлению](#оглавление)

#### create

Создает новую запись.

```
create({
  data: _data,
  select?: fields,
  include?: relations
})
```

- _data — данные создаваемой записи.

[^ к оглавлению](#оглавление)

#### update

Обновляет существующую запись.

```
update({
  data: _data,
  where: condition,
  select?: fields,
  include?: relations
})
```

[^ к оглавлению](#оглавление)

#### upsert

Обновляет существующую или создает новую запись.

```
upsert({
  create: _data,
  update: _data,
  where: condition,
  select?: fields,
  include?: relations
})
```

[^ к оглавлению](#оглавление)

#### delete

Удаляет существующую запись по идентификатору или уникальному полю.

```
delete({
  where: condition,
  select?: fields,
  include?: relations
})
```

[^ к оглавлению](#оглавление)

#### createMany

Создает несколько записей за один запрос.

```
createMany({
  data: _data[],
  skipDuplicates?: boolean
})
```

- _data[] — данные для создаваемых записей в виде массива;
- skipDuplicates — при значении true создаются только уникальные записи.

[^ к оглавлению](#оглавление)

#### updateMany

Обновляет несколько существующих записей за один раз и возвращает количество обновленных записей.

```
updateMany({
  data: _data[],
  where?: condition
})
```

[^ к оглавлению](#оглавление)

#### deleteMany

Удаляет несколько записей с помощью одной транзакции и возвращает количество удаленных записей.

```
deleteMany({
  where?: condition
})
```

[^ к оглавлению](#оглавление)

#### count

Возвращает количество записей, соответствующих заданному критерию.

```
count({
  where?: condition,
  select?: fields,
  cursor?: position,
  orderBy?: order,
  skip?: number,
  take?: number
})
```

[^ к оглавлению](#оглавление)

#### aggregate

Выполняет агрегирование полей.

```
aggregate({
  where?: condition,
  select?: fields,
  cursor?: position,
  orderBy?: order,
  skip?: number,
  take?: number,

  _count: count,
  _avg: avg,
  _sum: sum,
  _min: min,
  _max: max
})
```

- _count — возвращает количество совпадающих записей или не null-полей;
- _avg — возвращает среднее значение определенного поля;
- _sum — возвращает сумму значений определенного поля;
- _min — возвращает наименьшее значение определенного поля;
- _max — возвращает наибольшее значение определенного поля.

[^ к оглавлению](#оглавление)

#### groupBy

Выполняет группировку полей.

```
groupBy({
  by?: by,
  having?: having,

  where?: condition,
  orderBy?: order,
  skip?: number,
  take?: number,

  _count: count,
  _avg: avg,
  _sum: sum,
  _min: min,
  _max: max
})
```

- by — определяет поле или комбинацию полей для группировки записей;
- having — позволяет фильтровать группы по агрегируемому значению.

[^ к оглавлению](#оглавление)

### Вложенные запросы в Prisma

#### create

Добавляет новую связанную запись или набор записей в родительскую запись.

create доступен при создании (create) новой родительской записи или обновлении (update) существующей родительской записи.

```
await prisma.user.create({
  data: {
    email,
    profile: {
      create: {
        first_name,
        last_name
      }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### createMany

Добавляет набор новых связанных записей в родительскую запись.

createMany доступен при создании (create) новой родительской записи или обновлении (update) существующей родительской записи.

```
await prisma.user.create({
  data: {
    email,
    posts: {
      createMany: {
        data: posts
      }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### update

Обновляет одну или более связанных записей

```
await prisma.user.update({
  where: { email },
  data: {
    profile: {
      update: { age }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### updateMany

Обновляет массив связанных записей. Поддерживается фильтрация.

```
await prisma.user.update({
  where: { id },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false
        },
        data: {
          like_count: 0
        }
      }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### upsert

Обновляет существующую связанную запись или создает новую.

```
await prisma.user.update({
  where: { email },
  data: {
    profile: {
      upsert: {
        create: { age },
        update: { age }
      }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### delete

Удаляет связанную запись. Родительская запись при этом не удаляется.

```
await prisma.user.update({
  where: { email },
  data: {
    profile: {
      delete: true
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### deleteMany

Удаляет связанные записи. Поддерживается фильтрация.

```
await prisma.user.update({
  where: { id },
  data: {
    age,
    posts: {
      deleteMany: {}
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### set

Перезаписывает значение связанной записи.

```
await prisma.user.update({
  where: { email },
  data: {
    posts: {
      set: newPosts
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### connect

Подключает запись к существующей связанной записи по идентификатору или уникальному полю.

```
await prisma.post.create({
  data: {
    title,
    content,
    author: {
      connect: { email }
    }
  }
})
```

[^ к оглавлению](#оглавление)

#### connectOrCreate

Подключает запись к существующей связанной записи по идентификатору или уникальному полю либо создает связанную запись при отсутствии таковой.

[^ к оглавлению](#оглавление)

#### disconnect

Отключает родительскую запись от связанной без удаления последней.

disconnect доступен только если отношение является опциональным.

[^ к оглавлению](#оглавление)

### Поля запросов в Prisma

#### select

Определяет, какие поля включаются в возвращаемый объект.

```
  select: {
    id: true,
    email: true,
    first_name: true,
    last_name: true,
    age: true
  }

  select: {
    id: true,
    email: true,
    posts: {
      select: {
        id: true,
        title: true,
        content: true,
        author_id: true,
        created_at: true
      }
    }

  select: {
    id: true,
    email: true,
    posts: {
      include: {
        comments: true
      }
    }
  }
```

[^ к оглавлению](#оглавление)

#### include

Определяет, какие отношения (связанные записи) включаются в возвращаемый объект.

```
  include: {
    posts: true,
    comments: true
  }
```

[^ к оглавлению](#оглавление)

#### where

Определяет один или более фильтр (о фильтрах мы поговорим отдельно), применяемый к свойствам записи или связанных записей:

```
  where: {
    email: email
  }

  where: {
    email: {
      contains: 'admin'
    }
  }
```

[^ к оглавлению](#оглавление)

#### orderBy

Определяет поля и порядок сортировки. Возможными значениями orderBy являются asc и desc.

```
  orderBy: {
    posts: {
      count: 'desc'
    }
  }
```

[^ к оглавлению](#оглавление)

#### distinct

Определяет поля, которые должны быть уникальными в возвращаемом объекте.

```
  select: {
    city: true,
    country: true
  },
  distinct: ['city']
```

[^ к оглавлению](#оглавление)

### Фильтры и операторы в Prisma

#### equals

Значение равняется n.

```
  where: {
    name: {
      equals: 'Harry'
    }
  }
```

Обычно **equals** может быть опущено:

```
  where: {
    name: 'Harry'
  }
```

[^ к оглавлению](#оглавление)

#### not

Значение не равняется n.

[^ к оглавлению](#оглавление)

#### in

Значение n содержится в списке (массиве).

```
  where: {
    user_name: {
      in: ['Alice', 'Bob']
    }
  }
```

[^ к оглавлению](#оглавление)

#### notIn

n не содержится в списке.

[^ к оглавлению](#оглавление)

#### lt

n меньше x.

```
  where: {
    likeCount: {
      lt: 100
    }
  }
```

[^ к оглавлению](#оглавление)

#### lte

n меньше или равно x.

[^ к оглавлению](#оглавление)

#### gt

n больше x.

[^ к оглавлению](#оглавление)

#### gte

n больше или равно x.

[^ к оглавлению](#оглавление)

#### contains

n содержит x.

```
  where: {
    email: {
      contains: 'admin'
    }
  }
```

[^ к оглавлению](#оглавление)

#### startsWith

n начинается с x.

```
  where: {
    user_name: {
      startsWith: 'A'
    }
  }
```

[^ к оглавлению](#оглавление)

#### endsWith

n заканчивается x

[^ к оглавлению](#оглавление)

#### AND

Все условия должны возвращать true.

```
  where: {
    AND: [
      {
        title: {
          contains: 'TypeScript'
        }
      },
      {
        published: false
      }
    ]
  }
```

Обратите внимание: оператор указывается до названия поля (снаружи поля), а фильтр после (внутри).

[^ к оглавлению](#оглавление)

#### OR

Хотя бы одно условие должно возвращать true.

[^ к оглавлению](#оглавление)

#### NOT

Все условия должны возвращать false.

[^ к оглавлению](#оглавление)

#### some

Возвращает все связанные записи, соответствующие одному или более критерию фильтрации.

```
  where: {
    posts: {
      some: {
        title: {
          contains: 'TypeScript'
        }
      }
    }
  }
```

[^ к оглавлению](#оглавление)

#### every

Возвращает все связанные записи, соответствующие всем критериям.

[^ к оглавлению](#оглавление)

#### none

Возвращает все связанные записи, не соответствующие ни одному критерию.

[^ к оглавлению](#оглавление)

#### is

Возвращает все связанные записи, соответствующие критерию.

[^ к оглавлению](#оглавление)

#### notIs

Возвращает все связанные записи, не соответствующие критерию.

[^ к оглавлению](#оглавление)

## Прямая обработка запросов

Подробнее см. здесь:

https://expressjs.com/ru/guide/database-integration.html

[^ к оглавлению](#оглавление)

# Встроенные возможности

## Авторизация

Для авторизации мы используем таблицу **auth**, включая одноименный путь, а также все необходимые контроллеры, middleware, модель и сервисы.

Данная таблица используется отдельно от других данных пользователя и предназначена только для авторизации и регистрации.

Таблица содержит следующие поля:

- id,
- created_at,
- updated_at,
- login,
- password,
- refresh_token,
- confirm_code,
- is_activated.

Мы предполагаем, что поле **login** будет содержать email пользователя, но намеренно сделали его обезличенным.

Также существуют вспомогательные поля с кодом подтверждения и статусом того, что регистрация пользователя подтверждена и он является активным.

По полю **id** можно идентифицировать пользователя в других таблицах.

> Например, в таблице **users** использовать поле **user_id**.

Также при авторизации генерируется токен **jwt**. Для генерации используется ключ **JWT_ACCESS** из переменных окружения. Можно также задать время жизни этого токена.

Наличие и проверка этого токена дает нам возможность убедиться, что запрос к API не является поддельным. За проверку отвечает middleware **authProtect**.

Но в базе данных хранится другой токен, отвечающий за получение нового оригинального токена. Чтобы смена токенов осуществлялась скрыто от пользователя и без его отключения.

Так достигается безопасность.

[^ к оглавлению](#оглавление)

### Авторизация по номеру телефона

Вы можете использовать поле **login** не для email, а для регистрации по номеру телефона с отправкой кода подтверждения по СМС или в мессенджер.

Базовая реализация предполагает отправку по email. Для отправки по другим каналам, вам придется использовать другие библиотеки.

Если же вам понадобится использовать и email, и номер телефона, вам придется продублировать поля

- login,
- confirm_code,
- is_activated

и логику работы контроллера.

[^ к оглавлению](#оглавление)

### Авторизация без подтверждения

Вы можете и вовсе отключить механизм подтверждения. Для этого достаточно записать значение **true** в поле **is_activated** при регистрации.

[^ к оглавлению](#оглавление)

### Двухфакторная аутентификация

Двухфакторная аутентификация подразумевает подтверждение email или телефона каждый раз при авторизации.

Для этого достаточно поменять код таким образом, чтобы поле **is_activated** сбрасывалось после каждой успешной авторизации.

[^ к оглавлению](#оглавление)

# Расширение функционала

## Установка зависимостей

Вы можете расширять возможности сервера при помощи библиотек. Такие библиотеки в контексте установки в проект называются зависимостями.

Установить библиотеку:

```shell script
yarn add LIBRARY
```

Удалить библиотеку:

```shell script
yarn remove LIBRARY
```

Также можно устанавливать и удалять несколько библиотек сразу, перечислив их через пробел:

```shell script
yarn add LIBRARY1 LIBRARY2 LIBRARY3
```

[^ к оглавлению](#оглавление)

## Подключение библиотек

Подключать библиотеки к проекту нужно в каждом **js** файле, где вы будете их использовать.

Подключить библиотеку к проекту:

```
import LIBRARY from 'LIBRARY'
```

Подключить определенные константы, объекты или функции:

```
import { OBJECT1, OBJECT2 } from 'LIBRARY'
```

Подключить все ресурсы библиотеки:

```
import * from 'LIBRARY'
```

[^ к оглавлению](#оглавление)

## Сервер статики

Для вывода статики вы можете использовать другой наш сервер:

https://github.com/isengine/bss

[^ к оглавлению](#оглавление)

## Рабочее окружение

Для облегчения процесса разработки, вы можете развернуть наше рабочее окружение:

https://github.com/isengine/lds

[^ к оглавлению](#оглавление)

# Правила

При разработке мы следуем нескольким простым правилам.

[^ к оглавлению](#оглавление)

## Именование

### Обычное именование

Для названия всех сущностей мы используем camelCase.

Например:

```
const myConst = ...
function myFunc(firstArgument, secondArgument)...
```

Да, обычно классы именуются с большой буквы. Но давайте будем честны, в большинстве случаев мы замыкаем классы и объекты в константы. К тому же в коде для нас нет большой разницы между методами, свойствами и ключами объекта.

[^ к оглавлению](#оглавление)

### Именование в базах данных

Для названия таблиц и полей в базе данных мы используем snake_case.

Например:

```
first_field
second_field
```

Однако при их переходе в код js, имена преобразуются в camelCase:

```
firstField
secondField
```

[^ к оглавлению](#оглавление)

### Именование сущностей булевого типа

Если переменные, константы или поля объекта являются булевым типом, а также если функции возвращают булев тип, то в начале их имени ставится **is**.

Например:

```
const isActivated = ...

if (isRegistered()) ...

class className {
  isNotEmpty: true
  ...
}
```

[^ к оглавлению](#оглавление)

### Именование действий

Иногда сущность является действием. Например это функция, метод или константа, которая служит псевдонимом для функции. В таком случае ее имя наверняка будет содержать глагол.

В этом случае глагол выносится вперед.

Например:

```
readUser
readUserLogin
```

[^ к оглавлению](#оглавление)

### Именование определений

Определение сущности, главное имя, всегда выносится вперед.

Например:

```
userLogin
userPassword
```

Как вы видели выше, обычно вперед выносится глагол. Но иногда вам может понадобится дать определение сущности.

Например, когда у вас есть несколько похожих функций для разных сущностей.

```
userReadId
userReadPassword
adminReadId
adminReadPassword
```

Однако появление таких имен сигнализирует о том, что с кодом что-то не так.

Например, можно использовать класс, чтобы стало хотя бы вот так:

```
user.readId
user.readPassword
admin.readId
admin.readPassword
```

А еще лучше - деструктуризацию, чтобы стало вот так:

```
{ userId, userPassword } = readUser
{ adminId, adminPassword } = readAdmin
```

[^ к оглавлению](#оглавление)

### Полное и краткое именование

Не старайтесь максимально сокращать и избегать более полного именования.

Сравните:

```
ult
# и
userLogoutAtTime
```

В то же время можно сокращать общепринятые термины и понятия, и избавляться от явных вещей.

Сравните:

```
const constantUserNumberAsInteger
funcGetUserInteger(value)
# и
const userNum
getUserInt(val)
```

### Именование файлов

Бывают случи, когда вы храните сущности в одной папке:

```
controllers
├── adminRead.js
├── adminWrite.js
├── adminCreate.js
├── adminDelete.js
├── userRead.js
├── userWrite.js
├── userCreate.js
└── userDelete.js
```

Здесь имеет смысл разделить их на две разные папки:

```
controllers
├── admin
│   └──...
└── user
    └──...
```

Но встает вопрос, менять ли теперь название сущностей?

На первый взгляд **user/read** смотрится лучше, чем **user/userRead**. Но что будет, если в одном коде встретятся разные сущности с одним и тем же названием?

```
import { read } from './controllers/user/read.js'
import { read } from './controllers/admin/read.js'
```

Можно использовать разное название через оператор **as** или через название самой сущности внутри файла.

```
import { read as readUser } from './controllers/user/read.js'
import { read as readAdmin } from './controllers/admin/read.js'
```

Можно сделать так:

```
export const readUser ...

...

export const readAdmin ...

...

import { readUser } from './controllers/user/readUser.js'
import { readAdmin } from './controllers/admin/readAdmin.js'
```

Но вообще появление такого кода сигнализирует о том, что с кодом что-то не так.

В этом случае, возможно, лучшим решением будет поменять всю структуру и использовать классы.

```
controllers
├── admin
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── user
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── admin.js
└── user.js
```

В файлах **admin.js** и **user.js** импортировать все сущности, а затем собрать их в классы и экспортировать.

```
import { read } from './admin/read.js'
...

export default class Admin {
  read: read,
  ...
}
```

```
import { read } from './user/read.js'
...

export default class User {
  read: read,
  ...
}
```

Теперь вы можете использовать их намного проще:

```
import userController from './controllers/user.js'
import adminController from './controllers/admin.js'

userController.read()
adminController.read()
```

[^ к оглавлению](#оглавление)

### Что дают правила именования

Следование этим правилом помогает читать код и интуитивно понимать, что перед вами, независимо от контекста.

Смотрите:

```
# булев тип
... isActivated ...

# константа или объект
... userLogin ...

# функция или метод
... readUser ...

# класс
... UserClassName ...
```

Мы инициализируем классы в константы с маленькой буквы.

Смотрите:

```
# импортируем класс
import SomeClass from './someClass'

# инициализируем класс
const someClass = new SomeClass()
```

В результате инициализированные классы у нас с маленькой буквы, и объекты у нас тоже с маленькой буквы. Но это нам ничуть не мешает. Потому что функцию или метод мы отличаем синтаксически.

Смотрите:

```
# константа
... someEntity ...

# ключ объекта или свойство класса
... someEntity.someName ...

# метод класса
... someEntity.someMethod() ...
```

[^ к оглавлению](#оглавление)
