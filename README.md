# Среда разработки

BRAS - сокращенно от Backend RESTful API Server, backend сервер API запросов в формате REST.

Это сервер, построенный на базе Node.js, который может использоваться в качестве backend части для ваших веб приложений.

# Оглавление

- [Быстрый старт](#быстрый-старт)
- [О проекте](#о-проекте)
  - [Состав](#состав)
  - [Структура](#структура)
- [API](#api)
  - [Запросы к API](#запросы-к-api)
  - [Путь к API](#путь-к-api)
- [Базы данных](#базы-данных)
  - [GraphQL](#graphql)
  - [Prisma](#prisma)
  - [Прямая обработка запросов](#прямая-обработка-запросов)
- [Встроенные возможности](#встроенные-возможности)
  - [Авторизация](#авторизация)
    - [Авторизация по номеру телефона](#авторизация-по-номеру-телефона)
    - [Авторизация без подтверждения](#авторизация-без-подтверждения)
    - [Двухфакторная аутентификация](#двухфакторная-аутентификация)
- [Расширение функционала](#расширение-функционала)
  - [Установка зависимостей](#установка-зависимостей)
  - [Подключение библиотек](#подключение-библиотек)
  - [Сервер статики](#сервер-статики)
  - [Рабочее окружение](#рабочее-окружение)
- [Правила](#правила)
  - [Именование](#именование)
    - [Обычное именование](#обычное-именование)
    - [Именование в базах данных](#именование-в-базах-данных)
    - [Именование сущностей булевого типа](#именование-сущностей-булевого-типа)
    - [Именование действий](#именование-действий)
    - [Именование определений](#именование-определений)
    - [Полное и краткое именование](#полное-и-краткое-именование)
    - [Именование файлов](#именование-файлов)
    - [Что дают правила именования](#что-дают-правила-именования)

# Быстрый старт

Быстрый запуск в 5 простых шагов.

**1**. Выполните клонирование данного репозитория в текущий каталог backend части вашего проекта.

```shell script
git clone https://github.com/isengine/bras .
```

**2**. Выполните компиляцию

Рекомендуем использовать **yarn**.

```shell script
yarn
```

**3**. Сделайте настройки

Внесите необходимые настройки в файле **.env**.

- режим компиляции,
- порт,
- ключ для jwt токена,
- путь к API,
- путь к интерфейсу GraphQL.

Добавьте нужные пути и методы в файле **routes.js**.

**4**. Разверните базу данных

Укажите путь к базе данных в файле **.env**.

Если у вас новая база данных, выполните миграцию

```
yarn prisma migrate dev
```

**5**. Соберите проект

В режиме **production**:

```shell script
yarn start
```

В режиме разработки **development**:

```shell script
yarn dev
```

Вывод проекта через node.js на 8080 порт: http://localhost:8080

> В случае необходимости изменить конфигурацию сервера, возникновения ошибок и прочих вопросов, смотрите полное руководство.

[^ к оглавлению](#оглавление)

# О проекте

## Состав

Backend использует следующие технологии:

- express
- graphql
- jwt
- mysql
- nodejs
- postgres
- prisma
- yarn

[^ к оглавлению](#оглавление)

## Структура

```
bras
├── api
│   ├── RESOURCE
│   │   ├── controller
│   │   ├── dto
│   │   ├── middleware
│   │   ├── model
│   │   ├── service
│   │   ├── RESOURCE.controller.js
│   │   ├── RESOURCE.dto.js
│   │   ├── RESOURCE.middleware.js
│   │   ├── RESOURCE.model.js
│   │   └── RESOURCE.service.js
│   └── routes.js
├── prisma
│   ├── prisma.js
│   └── schema.prisma
├── schema
│   ├── mutations
│   ├── queries
│   ├── resolvers
│   ├── resolvers.js
│   ├── schema.js
│   └── typeDefs.js
├── .env
├── package.json
└── server.js
```

[^ к оглавлению](#оглавление)

# API

## Запросы к API

Работа с API предлагает использовать всю мощь фреймворка Express.js и платформы Node.js.

Мы используем стандарт RESTful API.

Так выглядит пример запроса:

```
/api/resource/endpoint
```

- **api** является точкой входа,
- **resource** указывает на запрашиваемый ресурс,
- **endpoint** может содержать сложный путь, даже с некоторыми параметрами.

Параметры запроса передаются в виде JSON.

Вызываемый ресурс контролируется в файле **routes.js**. Там же назначается метод HTTP-запроса:

- GET, получает полные данные (тело и заголовки),
- HEAD, получает только заголовки (служебную информацию),
- POST, отправляет данные на сервер,
- PUT, отправляет запрос на создание нового ресурса на сервере, либо на замену существующего,
- PATCH, отправляет запрос на изменение фрагмента ресурса,
- DELETE, отправляет запрос на удаление ресурса,
- CONNECT, устанавливает постоянную двунаправленную связь (туннель) с сервером,
- OPTIONS, отправляет запрос на получение параметров соединения,
- TRACE, отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе).

Методы GET, HEAD и OPTIONS считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию методы GET и HEAD кэшируются, остальные - нет. Поэтому при использовании метода POST можно быть уверенным, что запрос выполнится. В случае с GET Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

Также **routes.js** назначает один или несколько обработчиков для этого ресурса.

Ресурсы представляют собой четко структурированные папки. Мы призываем придерживаться этой структуры в создании собственных ресурсов.

Обработчики представляют из себя контроллеры или middleware и лежат в соответствующих папках.

В большинстве случаев контроллеры отправляют запросы в базу данных и, возможно, дополнительно обрабатывают данные. Но также контроллеры могут содержать и другие действия, например, по работе с файлами.

Все эти действия лежат в папке **services**.

Еще одна папка содержит модели данных. Эти модели могут понадобится при обработке данных. Например, после запроса в базу, мы можем получить больше данных, чем захотим отдать. Модель указывает на те данные, которые мы хотим вернуть.

Типовой пример - пароль пользователя. Он приходит в запросе и мы должны его сверить. Кончно, он хешированный, но даже в таком виде нам незачем его передавать в приложение.

Другой пример - номер телефона или email, который может служить для авторизации, но мы также не будет его передавать в приложение.

Такая структура позволяет создать максимально понятное API, удобное для программирования, со слабо связанными компонентами.

Также при написании контроллеров и middleware, вы можете использовать свои сервисы, подключенные в виде библиотек.

[^ к оглавлению](#оглавление)

## Путь к API

Путь настраивается в файле **.env** в переменной окружения **API_BASE**.

По-умолчанию:

```
API_BASE = /api
```

Если вы используете для вашего API отдельный домен, вы можете указать пустой путь:

```
API_BASE =
```

Если вы используете разные версии API, то вы можете добавить к пути номер версии. Например, так:

```
API_BASE = /api/v3
```

[^ к оглавлению](#оглавление)

# Базы данных

Для работы с базами данных мы предлагаем несколько способов:

- GraphQL
- ORM Prisma
- прямая обработка запросов

Конечно, в приоритете GraphQL. Если вам это кажется еще сложным, либо вы на пути миграции вашего приложения, рекомендуемый выбор - Prisma.

Почему мы не рекомендуем осуществлять прямую обработку запросов? Смотрите, вам придется самостоятельно:

- устанавливать и настраивать расширения для Express.js,
- писать запросы,
- контролировать безопасность принимаемых данных,
- осуществлять типизацию выходных данных.

[^ к оглавлению](#оглавление)

## GraphQL

Работа с GraphQL построена на связке расширения для Express.js + GraphiQL + Prisma.

Данная связка на данный момент является самой перспективной. Во-первых, она очень быстро развивается. Во-вторых, она может сделать переход вашего приложения на GraphQL минимально безболезненным.

И это является еще одной причиной не использовать прямую обработку запросов.

Команда Prisma является активными участниками сообщества разработчиков GraphQL. Уже сейчас мы можем получить более удобные способы взаимодействия Prisma с GraphQL.

Раньше мы использовали Apollo, но это нам показалось не лучшим решением, т.к. приходилось вызывать Apollo как middleware в Express. Мы не использовали Apollo никак, кроме обеспечения работы с GraphQL, и поэтому отказались от него в пользу решения непосредственно для Express.js.

Однако Apollo является более перспективным, чем Express. Он активно развивается. И в дальнейшем мы можем отказаться от фреймворка Express.js в пользу Apollo.

Схема GraphQL находится в папке **schema**. Для удобства она разбита на **resolvers**, **queries** и **mutations**. Все сущности из этих папок собираются в файле **resolvers.js**. Определение типов по-прежнему задается в одном файле **typeDefs.js**.

Схема доступна из кода:

```
import { schema } from '#schema/schema'
```

Мы работаем над тем, чтобы типы тоже можно было задавать в разных файлах.

[^ к оглавлению](#оглавление)

## Prisma

Prisma позволяет контролировать типизацию и упрощает работу.

Prisma дает возможность работать с любой из следующих баз данных:

- MongoDB,
- MySQL,
- PostgreSQL,
- SQLite

и некоторыми другими.

Причем настройка и подключение осуществляются парой строк кода со сменой провайдера.

Вся работа построена на прописывании схемы с моделями данных в собственном формате Prisma. С одной стороны это лишний костыль, с другой это позволяет использовать большую мощь Prisma.

Например, вы получаете:

- типизированную структуру,
- простую миграцию.

Схема Prisma находится в папке **prisma** и по-прежнему задается в одном файле **schema.prisma**.

Мы работаем над тем, чтобы можно было разделить схему на разные файлы.

Схема доступна из кода:

```
import { prisma } from '#prisma'
```

Существуют библиотеки, позволяющие из схемы Prisma построить схему GraphQL.

Обновление базы данных может происходить за счет вызова миграции.

```shell script
prisma migrate dev
```

Чтобы настроить в Prisma зависимости между двумя таблицами, нужно связать обе таблицы.

model Auth {
  id            Int       @id @default(autoincrement())
  ...
  User          User[]
}

model User {
  id            Int       @id @default(autoincrement())
  ...
  userId        Int?      @map("user_id")
  Auth          Auth?     @relation(fields: [userId], references: [id])
}


[^ к оглавлению](#оглавление)

## Прямая обработка запросов

Подробнее см. здесь:

https://expressjs.com/ru/guide/database-integration.html

[^ к оглавлению](#оглавление)

# Встроенные возможности

## Авторизация

Для авторизации мы используем таблицу **auth**, включая одноименный путь, а также все необходимые контроллеры, middleware, модель и сервисы.

Данная таблица используется отдельно от других данных пользователя и предназначена только для авторизации и регистрации.

Таблица содержит следующие поля:

- id,
- created_at,
- updated_at,
- login,
- password,
- refresh_token,
- confirm_code,
- is_activated.

Мы предполагаем, что поле **login** будет содержать email пользователя, но намеренно сделали его обезличенным.

Также существуют вспомогательные поля с кодом подтверждения и статусом того, что регистрация пользователя подтверждена и он является активным.

По полю **id** можно идентифицировать пользователя в других таблицах.

> Например, в таблице **users** использовать поле **user_id**.

Также при авторизации генерируется токен **jwt**. Для генерации используется ключ **JWT_SECRET** из переменных окружения. Можно также задать время жизни этого токена.

Наличие и проверка этого токена дает нам возможность убедиться, что запрос к API не является поддельным. За проверку отвечает middleware **authProtect**.

Но в базе данных хранится другой токен, отвечающий за получение нового оригинального токена. Чтобы смена токенов осуществлялась скрыто от пользователя и без его отключения.

Так достигается безопасность.

[^ к оглавлению](#оглавление)

### Авторизация по номеру телефона

Вы можете использовать поле **login** не для email, а для регистрации по номеру телефона с отправкой кода подтверждения по СМС или в мессенджер.

Базовая реализация предполагает отправку по email. Для отправки по другим каналам, вам придется использовать другие библиотеки.

Если же вам понадобится использовать и email, и номер телефона, вам придется продублировать поля

- login,
- confirm_code,
- is_activated

и логику работы контроллера.

[^ к оглавлению](#оглавление)

### Авторизация без подтверждения

Вы можете и вовсе отключить механизм подтверждения. Для этого достаточно записать значение **true** в поле **is_activated** при регистрации.

[^ к оглавлению](#оглавление)

### Двухфакторная аутентификация

Двухфакторная аутентификация подразумевает подтверждение email или телефона каждый раз при авторизации.

Для этого достаточно поменять код таким образом, чтобы поле **is_activated** сбрасывалось после каждой успешной авторизации.

[^ к оглавлению](#оглавление)

# Расширение функционала

## Установка зависимостей

Вы можете расширять возможности сервера при помощи библиотек. Такие библиотеки в контексте установки в проект называются зависимостями.

Установить библиотеку:

```shell script
yarn add LIBRARY
```

Удалить библиотеку:

```shell script
yarn remove LIBRARY
```

Также можно устанавливать и удалять несколько библиотек сразу, перечислив их через пробел:

```shell script
yarn add LIBRARY1 LIBRARY2 LIBRARY3
```

[^ к оглавлению](#оглавление)

## Подключение библиотек

Подключать библиотеки к проекту нужно в каждом **js** файле, где вы будете их использовать.

Подключить библиотеку к проекту:

```
import LIBRARY from 'LIBRARY'
```

Подключить определенные константы, объекты или функции:

```
import { OBJECT1, OBJECT2 } from 'LIBRARY'
```

Подключить все ресурсы библиотеки:

```
import * from 'LIBRARY'
```

[^ к оглавлению](#оглавление)

## Сервер статики

Для вывода статики вы можете использовать другой наш сервер:

https://github.com/isengine/bss

[^ к оглавлению](#оглавление)

## Рабочее окружение

Для облегчения процесса разработки, вы можете развернуть наше рабочее окружение:

https://github.com/isengine/lds

[^ к оглавлению](#оглавление)

# Правила

При разработке мы следуем нескольким простым правилам.

[^ к оглавлению](#оглавление)

## Именование

### Обычное именование

Для названия всех сущностей мы используем camelCase.

Например:

```
const myConst = ...
function myFunc(firstArgument, secondArgument)...
```

Да, обычно классы именуются с большой буквы. Но давайте будем честны, в большинстве случаев мы замыкаем классы и объекты в константы. К тому же в коде для нас нет большой разницы между методами, свойствами и ключами объекта.

[^ к оглавлению](#оглавление)

### Именование в базах данных

Для названия таблиц и полей в базе данных мы используем snake_case.

Например:

```
first_field
second_field
```

Однако при их переходе в код js, имена преобразуются в camelCase:

```
firstField
secondField
```

[^ к оглавлению](#оглавление)

### Именование сущностей булевого типа

Если переменные, константы или поля объекта являются булевым типом, а также если функции возвращают булев тип, то в начале их имени ставится **is**.

Например:

```
const isActivated = ...

if (isRegistered()) ...

class className {
  isNotEmpty: true
  ...
}
```

[^ к оглавлению](#оглавление)

### Именование действий

Иногда сущность является действием. Например это функция, метод или константа, которая служит псевдонимом для функции. В таком случае ее имя наверняка будет содержать глагол.

В этом случае глагол выносится вперед.

Например:

```
readUser
readUserLogin
```

[^ к оглавлению](#оглавление)

### Именование определений

Определение сущности, главное имя, всегда выносится вперед.

Например:

```
userLogin
userPassword
```

Как вы видели выше, обычно вперед выносится глагол. Но иногда вам может понадобится дать определение сущности.

Например, когда у вас есть несколько похожих функций для разных сущностей.

```
userReadId
userReadPassword
adminReadId
adminReadPassword
```

Однако появление таких имен сигнализирует о том, что с кодом что-то не так.

Например, можно использовать класс, чтобы стало хотя бы вот так:

```
user.readId
user.readPassword
admin.readId
admin.readPassword
```

А еще лучше - деструктуризацию, чтобы стало вот так:

```
{ userId, userPassword } = readUser
{ adminId, adminPassword } = readAdmin
```

[^ к оглавлению](#оглавление)

### Полное и краткое именование

Не старайтесь максимально сокращать и избегать более полного именования.

Сравните:

```
ult
# и
userLogoutAtTime
```

В то же время можно сокращать общепринятые термины и понятия, и избавляться от явных вещей.

Сравните:

```
const constantUserNumberAsInteger
funcGetUserInteger(value)
# и
const userNum
getUserInt(val)
```

### Именование файлов

Бывают случи, когда вы храните сущности в одной папке:

```
controllers
├── adminRead.js
├── adminWrite.js
├── adminCreate.js
├── adminDelete.js
├── userRead.js
├── userWrite.js
├── userCreate.js
└── userDelete.js
```

Здесь имеет смысл разделить их на две разные папки:

```
controllers
├── admin
│   └──...
└── user
    └──...
```

Но встает вопрос, менять ли теперь название сущностей?

На первый взгляд **user/read** смотрится лучше, чем **user/userRead**. Но что будет, если в одном коде встретятся разные сущности с одним и тем же названием?

```
import { read } from './controllers/user/read.js'
import { read } from './controllers/admin/read.js'
```

Можно использовать разное название через оператор **as** или через название самой сущности внутри файла.

```
import { read as readUser } from './controllers/user/read.js'
import { read as readAdmin } from './controllers/admin/read.js'
```

Можно сделать так:

```
export const readUser ...

...

export const readAdmin ...

...

import { readUser } from './controllers/user/readUser.js'
import { readAdmin } from './controllers/admin/readAdmin.js'
```

Но вообще появление такого кода сигнализирует о том, что с кодом что-то не так.

В этом случае, возможно, лучшим решением будет поменять всю структуру и использовать классы.

```
controllers
├── admin
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── user
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── admin.js
└── user.js
```

В файлах **admin.js** и **user.js** импортировать все сущности, а затем собрать их в классы и экспортировать.

```
import { read } from './admin/read.js'
...

export default class Admin {
  read: read,
  ...
}
```

```
import { read } from './user/read.js'
...

export default class User {
  read: read,
  ...
}
```

Теперь вы можете использовать их намного проще:

```
import userController from './controllers/user.js'
import adminController from './controllers/admin.js'

userController.read()
adminController.read()
```

[^ к оглавлению](#оглавление)

### Что дают правила именования

Следование этим правилом помогает читать код и интуитивно понимать, что перед вами, независимо от контекста.

Смотрите:

```
# булев тип
... isActivated ...

# константа или объект
... userLogin ...

# функция или метод
... readUser ...

# класс
... UserClassName ...
```

Мы инициализируем классы в константы с маленькой буквы.

Смотрите:

```
# импортируем класс
import SomeClass from './someClass'

# инициализируем класс
const someClass = new SomeClass()
```

В результате инициализированные классы у нас с маленькой буквы, и объекты у нас тоже с маленькой буквы. Но это нам ничуть не мешает. Потому что функцию или метод мы отличаем синтаксически.

Смотрите:

```
# константа
... someEntity ...

# ключ объекта или свойство класса
... someEntity.someName ...

# метод класса
... someEntity.someMethod() ...
```

[^ к оглавлению](#оглавление)
